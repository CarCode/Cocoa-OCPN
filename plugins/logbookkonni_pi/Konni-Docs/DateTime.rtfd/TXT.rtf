{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf370
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww12600\viewh7800\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs24 \cf0 {{\NeXTGraphic page424image7104.png \width7940 \height20 \noorient
}¬}\pard\pardeftab720

\f1 \cf0 \
\pard\pardeftab720\sa240

\f0\fs22 \cf0 388
\f1\fs24 \

\f0\fs22 Data Structure Classes Chapter 13
\f1\fs24 \
\pard\pardeftab720\sa240

\f0\i\b\fs26 \cf0 wxDateTime
\f1\i0\b0\fs24 \
\pard\pardeftab720\sa240

\fs26 \cf0 The 
\fs22 wxDateTime 
\fs26 class has too many methods to include in a concise discussion; the complete API reference is available in the wxWidgets documentation. What is presented here is an overview of the most frequently used 
\fs22 wxDateTime 
\fs26 methods and operations.
\fs24 \

\fs26 Note that although time is always stored internally in Greenwich Mean Time (GMT), you will usually work in the local time zone. Because of this, all 
\fs22 wxDateTime 
\fs26 constructors and modifiers that compose a date or time from com- ponents (for example hours, minutes, and seconds) assume that these values are for the local time zone. All methods returning date or time components (month, day, hour, minute, second, and so on) will also return the correct val- ues for the local time zone by default; no effort is required to get correct results for your time zone. If you want to manipulate time zones, please refer to the documentation.
\fs24 \
\pard\pardeftab720\sa240

\f0\i\b \cf0 wxDateTime 
\i0 Constructors and Modifiers
\f1\b0 \
\pard\pardeftab720\sa240

\fs22 \cf0 wxDateTime 
\fs26 objects can be constructed from Unix timestamps, time-only infor- mation, date-only information, or complete date and time information. For each constructor, there is a corresponding 
\fs22 Set 
\fs26 method that modifies an exist- ing object to have the specified date or time. There are also individual modi- fiers such as 
\fs22 SetMonth 
\fs26 or 
\fs22 SetHour 
\fs26 that change just one component of the date or time.
\fs24 \

\fs22 wxDateTime(time_t) 
\fs26 constructs an object with the date and time set according to the specified Unix timestamp.
\fs24 \

\fs22 wxDateTime(const struct tm&) 
\fs26 constructs an object using the data from the C standard 
\fs22 tm 
\fs26 structure.
\fs24 \

\fs22 wxDateTime(wxDateTime_t hour, wxDateTime_t minute = 0, wxDateTime_t second = 0, wxDateTime_t millisec = 0) 
\fs26 constructs an object based on the spec- ified time information.
\fs24 \

\fs22 wxDateTime(wxDateTime_t day, Month month = Inv_Month, int year = Inv_Year, wxDateTime_t hour = 0, wxDateTime_t minute = 0, wxDateTime_t sec- ond = 0, wxDateTime_t millisec = 0) 
\fs26 constructs an object with the specified date and time information.
\fs24 \
\pard\pardeftab720\sa240

\f0\i\b \cf0 wxDateTime 
\i0 Accessors
\f1\b0 \
\pard\pardeftab720\sa240

\fs26 \cf0 The accessors for 
\fs22 wxDateTime 
\fs26 are mostly self-explanatory: 
\fs22 GetYear
\fs26 , 
\fs22 GetMonth
\fs26 , 
\fs22 GetDay
\fs26 , 
\fs22 GetWeekDay
\fs26 , 
\fs22 GetHour
\fs26 , 
\fs22 GetMinute
\fs26 , 
\fs22 GetSecond
\fs26 , 
\fs22 GetMillisecond
\fs26 , 
\fs22 GetDayOfYear
\fs26 , 
\fs22 GetWeekOfYear
\fs26 , 
\fs22 GetWeekOfMonth
\fs26 , and 
\fs22 GetYearDay
\fs26 . 
\fs22 wxDateTime 
\fs26 also provides the following:
\fs24 \

\f0\fs26 \uc0\u56319 \u56320 
\f1  
\fs22 GetTicks 
\fs26 returns the date and time in Unix timestamp format (seconds since January 1, 1970 at midnight).
\fs24 \

\f0\fs26 \uc0\u56319 \u56320 
\f1  
\fs22 IsValid 
\fs26 returns whether or not the object is in a valid state (the object could have been constructed but never given a date or time).
\fs24 \
\pard\pardeftab720\sa240

\f0\fs22 \cf0 Storing and Processing Dates and Times 389
\f1\fs24 \
\pard\pardeftab720\sa240

\f0\b \cf0 Getting the Current Time
\f1\b0 \
\pard\pardeftab720\sa240

\fs22 \cf0 wxDateTime 
\fs26 provides two static methods for retrieving the current time:\uc0\u8232 
\f0 \uc0\u56319 \u56320 
\f1  
\fs22 wxDateTime::Now 
\fs26 creates a 
\fs22 wxDateTime 
\fs26 object with the current time, accu-
\fs24 \

\fs26 rate to up the second.
\fs24 \

\f0\fs26 \uc0\u56319 \u56320 
\f1  
\fs22 wxDateTime::UNow 
\fs26 creates a 
\fs22 wxDateTime 
\fs26 object with the current time, including milliseconds.
\fs24 \
\pard\pardeftab720\sa240

\f0\b \cf0 Parsing and Formatting Dates
\f1\b0 \
\pard\pardeftab720\sa240

\fs26 \cf0 The functions in this section convert 
\fs22 wxDateTime 
\fs26 objects to and from text. The conversions to text are mostly trivial: you can use the default date and time representations for the current locale (
\fs22 FormatDate 
\fs26 and 
\fs22 FormatTime
\fs26 ), use the international standard representation defined by ISO 8601 (
\fs22 FormatISODate 
\fs26 and 
\fs22 FormatISOTime
\fs26 ), or specify any format at all by using 
\fs22 Format 
\fs26 directly.
\fs24 \

\fs26 The conversions from text are more interesting because there are many more possibilities. The simplest cases can be taken care of with 
\fs22 ParseFormat
\fs26 , which can parse any date in a specified (rigid) format. 
\fs22 ParseRfc822Date 
\fs26 parses dates using the format from RFC 822 that defines the format of email mes- sages on the Internet.
\fs24 \

\fs26 The most interesting functions are 
\fs22 ParseTime
\fs26 , 
\fs22 ParseDate, 
\fs26 and 
\fs22 ParseDateTime
\fs26 , which try to parse the date and/or time in \'93free\'94 format, allow- ing them to be specified in a variety of ways. These functions can be used to parse user input that is not bound by any predefined format. As an example, 
\fs22 ParseDateTime 
\fs26 can parse strings such as \'93tomorrow\'94, \'93March first\'94, and even \'93next Sunday\'94.
\fs24 \
\pard\pardeftab720\sa240

\f0\b \cf0 Date Comparisons
\f1\b0 \
\pard\pardeftab720\sa240

\fs26 \cf0 Two 
\fs22 wxDateTime 
\fs26 objects can easily be compared using one of many available comparison functions. All of these methods return 
\fs22 true 
\fs26 or 
\fs22 false
\fs26 .
\fs24 \

\fs26 The following methods all make comparisons to one other 
\fs22 wxDateTime 
\fs26 object: 
\fs22 IsEqualTo
\fs26 , 
\fs22 IsEarlierThan
\fs26 , 
\fs22 IsLaterThan
\fs26 , 
\fs22 IsSameDate, 
\fs26 and 
\fs22 IsSameTime
\fs26 .
\fs24 \

\fs26 The following methods all make comparisons using two other 
\fs22 wxDateTime 
\fs26 objects: 
\fs22 IsStrictlyBetween 
\fs26 and 
\fs22 IsBetween
\fs26 . The difference between these two is that 
\fs22 IsStrictlyBetween 
\fs26 would return 
\fs22 false 
\fs26 if the 
\fs22 wxDateObject 
\fs26 in question exactly equaled one of the range extremes, whereas 
\fs22 IsBetween 
\fs26 would return 
\fs22 true
\fs26 .
\fs24 \
\pard\pardeftab720\sa240

\f0\b \cf0 Date Arithmetic
\f1\b0 \
\pard\pardeftab720\sa240

\fs26 \cf0 wxWidgets provides two very robust classes for performing arithmetic on 
\fs22 wxDateTime 
\fs26 objects: 
\fs22 wxTimeSpan 
\fs26 and 
\fs22 wxDateSpan
\fs26 . 
\fs22 wxTimeSpan 
\fs26 is simply a difference in milliseconds and always gives fast, predictable results. On the other hand, time has larger meaningful units, such as weeks or months. 
\fs22 wxDateSpan 
\fs26 handles these operations in the most natural way possible, but note that manipulating
\fs24 \
\pard\pardeftab720\sa240

\f0\fs22 \cf0 390
\f1\fs24 \

\f0\fs22 Data Structure Classes Chapter 13
\f1\fs24 \
\pard\pardeftab720\sa240

\fs26 \cf0 intervals of this kind is not always well-defined. For example, Jan 31 plus one month will give Feb 28 (or 29), the last day of February, and not the non-exis- tent Feb 31. Of course, this is what is usually wanted, but you still might be surprised that subtracting back the same interval from Feb 28 will result in Jan 28 (not the January 31 that we started with).
\fs24 \

\fs26 Many different operations may be performed with the dates, but not all combinations of them make sense. For example, multiplying a date by a num- ber is an invalid operation, even though multiplying either of the time span classes by a number is perfectly valid.
\fs24 \

\f0\fs26 \uc0\u56319 \u56320 
\f1  
\b Addition
\b0 : A 
\fs22 wxTimeSpan 
\fs26 or 
\fs22 wxDateSpan 
\fs26 can be added to 
\fs22 wxDateTime 
\fs26 result- ing in a new 
\fs22 wxDateTime 
\fs26 object. Also, two objects of the same span class can be added together, resulting in another object of the same class.
\fs24 \

\f0\fs26 \uc0\u56319 \u56320 
\f1  
\b Subtraction
\b0 : The same operations as addition are valid for subtraction. Additionally, a difference between two 
\fs22 wxDateTime 
\fs26 objects can be taken and will return a 
\fs22 wxTimeSpan 
\fs26 object.
\fs24 \

\f0\fs26 \uc0\u56319 \u56320 
\f1  
\b Multiplication
\b0 : A 
\fs22 wxTimeSpan 
\fs26 or 
\fs22 wxDateSpan 
\fs26 object can be multiplied by an integer number, resulting in an object of the same type.
\fs24 \

\f0\fs26 \uc0\u56319 \u56320 
\f1  
\b Unary minus
\b0 : A 
\fs22 wxTimeSpan 
\fs26 or 
\fs22 wxDateSpan 
\fs26 object may be negated, resulting in an interval of the same magnitude but in the opposite time direction.
\fs24 \

\fs26 The following small code example demonstrates how to use 
\fs22 wxDateSpan 
\fs26 and 
\fs22 wxTimeSpan 
\fs26 to change the time stored in a 
\fs22 wxDateTime 
\fs26 object. See the wxWidgets manual for a complete list of available methods.
\fs24 \
\pard\pardeftab720

\fs22 \cf0 void TimeTests()\
\{\
    // Get the current day and time\
    wxDateTime DT1 = wxDateTime::Now();\
    // A span of 2 weeks and 1 day, or 15 days\
    wxDateSpan Span1(0, 0, 2, 1);\
    // Substract 15 days from today\
    wxDateTime DT2 = DT1 - Span1;\
    // Static creation of a one-day difference\
    wxDateSpan Span2 = wxDateSpan::Day();\
    // Span 3 will now be 14 days\
    wxDateSpan Span3 = Span1 - Span2;\
    // 0 days (the span is defined as 2 weeks)\
    int Days = Span3.GetDays();\
    // 14 days (2 weeks)\
    int TotalDays = Span3.GetTotalDays();\
    // 2 weeks into the past\
    wxDateSpan Span4 = -Span3;\
// A span of 3 months\
wxDateSpan Span5 = wxDateSpan::Month() * 3;\
// 10 hours, 5 minutes and 6 seconds\
wxTimeSpan Span6(10, 5, 6, 0);\
// Add the specified amount of time to DT2\
wxDateTime DT3 = DT2 + Span6;\
// Span7 is 3 times longer than Span6, but in the past\
wxTimeSpan Span7 = (-Span6) * 3;\
// SpanNeg will be true, the span is negative (in the past)\
bool SpanNeg = Span7.IsNegative();\
// Static creation of a span of one hour\
wxTimeSpan Span8 = wxTimeSpan::Hour();\
// One hour is not longer than 30+ hours (uses absolutes)\
bool Longer = Span8.IsLongerThan(Span7);\
\pard\pardeftab720\sa240
\cf0 \}
\fs24 \
}